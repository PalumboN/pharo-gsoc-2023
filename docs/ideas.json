[
  {
    "title": "Extension of Iceberg to support Fossil",
    "supervisors": [
      {
        "name": "Dave Mason"
        "email": "dmason@ryerson.ca"
      },
      {
        "name": "Guillermo Polito",
        "email": "guillermopolito@gmail.com "
      }
    ],
    "keywords": ["iceberg", "fossil"],
    "context": "Iceberg is a significant improvement for cooperative development on Pharo. It is intended to support multiple Version Control Systems, but currently only works with Git. Fossil is another VCS that is a more integrated, full feature alternative, particularly well suited to smaller team development.",
    "goal": "The goal of this project is to add an additional VCS to Iceberg. In addition to making the particular VCS available, dependencies on Git will be exposed and Iceberg will become more generic so that other VCSs, such as Mercurial or SVN, can be more easily added.",
    "level": ["Intermediate", "Advanced"]
  },
  {
    "title": "Classes and Methods for Spatial Data",
    "supervisors": [
      {
        "name": "Etienne Delay",
        "email": "etienne.delay@cirad.fr"
      }
      {
        "name": "Serge Stinckwich",
        "email": "serge.stinckwich@ird.fr"
      }
    ],
    "keywords": ["geography", "spatial data", "spatial data manipulation", "geographical grammar"],
    "context": "As a title of ''the economist'' The worldâ€™s most valuable resource is no longer oil, but data. Nowadays data and especially geospatial data become central in our societies. Each one of us needs to be able to deal with data and spatial data.",
    "goal": "We propose to explore structure to spatial data finding a way to load different types of geospatial data in Pharo. once the data is manipulable with our tools the goal is to develop some spatial method allowing for users to deal with spatial data. For that we will start from tools already existing in Pharo like the packages : Geometry, Shapes, geo-json and Territorial, but also in other programming languages (as R or python) in order to implement spatial methods for the community. The main objective will be first to be able to load a geojson file, to visualize it and to basic geometric operations.",
    "level": ["Beginner", "Intermediate"]
  },
  {
    "title": "SmartTest, a Test selection tool in a dynamically typed environment";
    "supervisors": [
      {
        "name": "Anne Etien",
        "email": "anne.etien@inria.fr"
      }
      {
        "name": "Nicolas Anquetil",
        "email": "nicolas.anquetil@inria.fr"
      }
    ],
    "keywords": ["test selection", "dynamic analysis", "static analysis"],
    "context": "Currently in Pharo, when the developer modifies code, he/she has to know which tests may have been broken to run them or in doubt run all the tests of the class or the project. In that later case, it can be very long. We would like to introduce in Pharo a test selection tool to help the developer in his/her selection. We already developed SmartTest, such a tool, but it is not useable in practice, since it is too long and too intrusive.",
    "goal": "Implement some strategies to enhance the performance of the tool. Evaluate these strategies on real cases studies in an a posteriori experiment. Configure and tune the tool. Evaluate the tool on the field by taking advantage of the community. Put it in the Pharo 8 distribution.",
    "level": ["Intermediate"]
  },
  {
    "title": "Closing the Loop",
    "supervisors": [
      {
        "name": "Stephan Eggermont",
        "email": "stephan@legacycode.nl"
      },
      {
        "name": "Christopher Fuhrman",
        "email": "christopher.fuhrman@etsmtl.ca"
      }
    ],
    "keywords": ["deprecations", "adaptability"],
    "context": "Pharo wants to be able to continue to change and adapt itself to an ever changing environment. In order to do that it needs to become more modular and make currently non-essential code easy to unload and reload on demand. With the in-system tests and CI there currently is a pretty good feedback loop telling Pharo developers when they break existing in-image code. That feedback loop is much weaker with external code. That code is often not developed in sync with the Pharo development. It is developed against a stable release or against the then current version of the development version. A lot of code is developed in student projects that don''t have the continuity that Pharo itself has. Other code is developed for specific customers who are not interested in upgrading it. Even if there are sufficient tests and an automated build for that code, there often is not enough incentive and priority for it to be kept up to date. Achieving more adaptability and agility for Pharo can be found by making it easier to keep more code up to date, or by making it easier to bring removed code up to date again. This proposal is about the latter. When refactoring or rewriting some code, looking at the senders of a message and references to a class is one of the basic things to do to get a good understanding of how that code is actually used. Currently that only works in-image. When Pharo was a 32-bit environment that made sense, but with the current support for large images it should be possible to provide that information for all open source smalltalk code, and also to provide historic/version information for it. Some experiments have been done already to establish the viability: code (for older Pharo versions) is available on smalltalkhub: StephanEggermont/DeprecationFinder and StephanEggermont/MonticelloProjects",
    "goal": "Analyze the source code of publicly available monticello/tonel packages and determine which classes and methods are used and defined by them (senders/references) (see DeprecationFinder). For Monticello use the history and deduplicate source code versions to reduce the amount of data that needs to be handled (see MonticelloProjects). Apply to projects on smalltalkhub and older repositories. Provide a api and a gui so Pharo developers can quickly access this information, and browse global and historic users.",
    "level": ["Advanced"]
  },
  {
    "title": "Projectional Editor for Advanced Pharo Debuggers",
    "supervisors": [
      {
        "name": "Steven Costiou",
        "email": "steven.costiou@inria.fr"
      },
      {
        "name": "Vincent Aranega",
        "email": "vincent.aranega@inria.fr"
      }
    ],
    "keywords": ["debugging", "editor", "ide", "ast"],
    "context": "Currently in Pharo, the Abstract Syntax Tree (AST) is generated from the source code, and stored into a cache. Each modification of the source code invalidates the cache and triggers the generation of a new AST object. Every annotation of the AST is lost in the process.",
    "goal": "Projectional editors make possible to edit different representation of the same underlying model. This project aims at building a projectional editor which manipulates an AST model instead of source code. With this tool, it will be possible to maintain a permanent representation of the system as an AST, and to new tools directly based on it, as new debugging tools.",
    "level": ["Intermediate"]
  },
  {
    "title": "Dependency Graph in the System Browser",
    "supervisors": [
      {
        "name": "Alexandre Bergel",
        "email": "alexandre.bergel@me.com"
      },
      {
        "name": "Milton Mamani",
        "email": "akevalion@gmail.com"
      }
    ],
    "keywords": ["visualization", "software engineering", "roassal"],
    "context": "Making the dependencies between software components explicit is known to be efficient at improving the quality of source code. Visualizations are commonly employed to represent dependencies between packages, classes, and methods.",
    "goal": "This project is about embedding a visualization within Calypso, the Pharo code browser, that represents dependencies between projects, packages, classes, and methods.",
    "level": ["Intermediate"]
  }
]
