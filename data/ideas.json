[
    {
        "title": "Dependency Graph in the System Browser",
        "supervisors": [
            "Milton Mamani",
            "Alexandre Bergel"
        ],
        "context": "Making the dependencies between software components explicit is known to be efficient at improving the quality of source code. Visualizations are commonly employed to represent dependencies between packages, classes, and methods.",
        "goal": "This project is about embedding a visualization within Calypso, the Pharo code browser, that represents dependencies between projects, packages, classes, and methods.",
        "keywords": [
            "visualization",
            "software engineering",
            "roassal"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Improving code completion",
        "supervisors": [
            "Guillermo Polito",
            "Juan Pablo Sandoval",
            "Evelyn Cusi Lopez"
        ],
        "context": "Automatic completion is really important. The current code completion already defines some good \nbehavior but it can do better.",
        "goal": "The goal of the project is to improve the ecompletion infrastructure: \nThe tasks are: \n(1) Study the new completion frameworks\n(3) Improve the noise introduced by the Symbol table usage, \n(4) build more heuristics.",
        "keywords": [
            "ide",
            "completion"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "DataFrame",
        "supervisors": [
            "Oleksandr Zaitsev",
            "Sebastian Jordan",
            "Serge Stinckwich",
            "Philippe Back"
        ],
        "context": "DataFrame was introduced to Pharo during the GSoC 2017 (https://github.com/PolyMathOrg/DataFrame). The work on DataFrame continued and many new features were introduced by different contributors. However, it is still a work in progress and a huge portion of functionality that can be found in other data frame packages (e.g. R, pandas) is missing.",
        "goal": "The goal of this project is to introduce new functionality to DataFrame (for example, handling missing values) and write examples of applying DataFrame to real problems of Data Science (one can reproduce examples from pandas and scikit-learn documentation, as well as some examples from R-bloggers)",
        "keywords": [
            "data science",
            "data analysis",
            "dataframe",
            "tabular data",
            "statistics"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Blockchain On Pharo",
        "supervisors": [
            "Santiago Bragagnolo"
        ],
        "context": "Blockchain is a pervasive technology. Interaction with distribtued smart contracts seems to be an unavoidable future. And the future is now.",
        "goal": "Pharo counts with a powerful library for interacting with Ethereum network. There are three main possible objectives: 1- enhance the navigation capabilities of Fog 2- Integrate Fog With Moose or 3- Enable new blockchain networks for the library",
        "keywords": [
            "pharo",
            "blockchain",
            "ethereum"
        ],
        "levels": [
            "Intermediate",
            "Advanced"
        ]
    },
    {
        "title": "3D CAD scripting using Smalltalk",
        "supervisors": [
            "Aik-Siong Koh"
        ],
        "context": "Just like Python, Smalltalk is an extremely flexible programming environment to create code. Smalltalk has the best IDE and debugger of any programming environment. 3D CAD and visualization is the standard way of presenting information nowadays expecially in Metaverse. FreeCAD and PythonOCC are open source CAD systems with powerful modeling capabilities and beautiful graphics. Both FreeCAD and PythonOCC use the  OpenCASCADE Technology (OCCT) which contains the 2D/3D modeling kernel of CAD technology. StOCC will be an open source attempt to combine the best of Pharo Smalltalk and OCCT. The knowledge gained will be used to improve StFreeCAD which uses Smalltalk code to drive FreeCAD directly. This project is to embed FreeCAD inside Pharo Smalltalk IDE.",
        "goal": "Combine the flexibility of Smalltalk with the 3D modeling and visualization of FreeCAD for maximum programming productivity.",
        "keywords": [
            "3d cad",
            "smalltalk",
            "scripting"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Improving DrTest",
        "supervisors": [
            "Stéphane Ducasse",
            "Aless Hosry",
            "Iona Thomas"
        ],
        "context": "DrTests is a Pharo tool that we use to run several tests cases at once.\nIt is very useful when developping because we have the power to run a selected scope of tests from different packages to control the situation of the tests.",
        "goal": "The goal is to improve DrTests, add more features to have a new version to it that will be the default Test Runner of Pharo.",
        "keywords": [
            "unit tests",
            "tools",
            "test runner"
        ],
        "levels": [
            "Beginner",
            "Intermediate"
        ]
    },
    {
        "title": "Linter for Moose",
        "supervisors": [
            "Anne Etien",
            "Nicolas Anquetil"
        ],
        "context": "Moose is a software analysis platform (https://modularmoose.org/). It allows to create tools to analyse, refactor, debug programs in “any” language. \nThis project will aim at building a linter for Moose: a tool that allows user to create new rules to check programs a bit like SonarQube or PMD.\nThis rules can be either paradigm specific but language independent, language specific, company specific or project specific.\nThe rules are a set of conditions that can be written using a query and that are composed.\nThis linter will rely on existing tool such as the query browser allowing to query models. But it will also propose (i) some recommendations to correct the rule violations and (ii) some visualisations for example to show which classes violates a given rule, or considering all the rules whose classes violate each of them and those violating several.",
        "goal": "",
        "keywords": [
            "tools",
            "transformation rules",
            "code recommendations",
            "code visualisations"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Implementing K-Means++ - Clustering Algorithms",
        "supervisors": [
            "Sebastian Jordan",
            "Oleksandr Zaitsev"
        ],
        "context": "Currently, in pharo-ai (https://github.com/pharo-ai/wiki) we have implemented the K-Means algorithm for unsupervised learning.\nNow, we would like to implement the K-Means++ variation.\nThis variation allows to choose more efficiently the centroids of the clustering to have better results.",
        "goal": "To have a working implementation of the K-Means++ algorithms and to release it as the default implementation of K-Means for Pharo-AI.",
        "keywords": [
            "ai",
            "machine learning",
            "unsupervised learning",
            "clustering"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Implementing A* - Graph Algorithms",
        "supervisors": [
            "Sebastian Jordan"
        ],
        "context": "Currently, in pharo-ai (https://github.com/pharo-ai/wiki) we have implemented several graphs algorithms.\nWe have a released working version of our graphs library.\nWe want to realse a second version and for that we would like to implement the A* algorithm.\nThe A* algorithm is one of the most well-know algorithms for space state search.\nThat is widely used in AI algorithms for doing smart searches.",
        "goal": "To have a working version of the A* algorithm for using it for smart searches.",
        "keywords": [
            "ai",
            "graphs algorithms",
            "state space search"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Machine Learning for (SmallLint) Quality Rules Profile",
        "supervisors": [
            "Oleksandr Zaitsev",
            "Stéphane Ducasse",
            "Sebastian Jordan"
        ],
        "context": "The idea is to use the Pharo-Ai/Machine learnign algorithms that are already available (https://github.com/pharo-ai/wiki) for detecting automatically transformations rules for improving the quality of the code.",
        "goal": "",
        "keywords": [
            "ai",
            "machine learning",
            "tansformation rules"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Gaussian Mixture Model - Clustering Algorithms",
        "supervisors": [
            "Sebastian Jordan",
            "Oleksandr Zaitsev"
        ],
        "context": "In Pharo-AI (https://github.com/pharo-ai/wiki), we have implemented the Gaussian Mixture Model clustering algorithm.\n The algorithm is well-written but there are some tunes that have to be done to have a first realese/stable version of it.",
        "goal": "To have a first stable release of the clustering, unsupervised machine learning algorithm: Gaussian Mixture Model",
        "keywords": [
            "ai",
            "machine learning",
            "clustering",
            "unsupervised learning"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Decision Tree Models",
        "supervisors": [
            "Sebastian Jordan",
            "Oleksandr Zaitsev"
        ],
        "context": "In Pharo-AI (https://github.com/pharo-ai/wiki), we have implemented a model for decision trees.\nWe want to tune this algorithm that we have to release a stable version that will be available to the public.",
        "goal": "To have a first stable release of the classification machine learning algorithm: Decision Tree Model",
        "keywords": [
            "ai",
            "machine learning",
            "classification",
            "decision tree"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "PCA Methods",
        "supervisors": [
            "Sebastian Jordan",
            "Oleksandr Zaitsev",
            "Hernán Morales"
        ],
        "context": "Write an object-model in Pharo to provide Principal Component Analysis (PCA) variants such as Sparse PCA, Randomized PCA, Incremental PCA and Kernel PCA (Centering).\nThe PolyMath library already provides an implementation of PCA which could be used as basis for extending with.",
        "goal": "",
        "keywords": [
            "pca",
            "sva",
            "dimensionality reduction"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Generic Data Structures to use in the VM",
        "supervisors": [
            "Pablo Tesone",
            "Guillermo Polito"
        ],
        "context": "Pharo VM is implemented using a Pharo language subset called Slang. This subset allows us to develop the Pharo VM as any other Pharo program. \n\t   By doing so, we can take profit of the power of Pharo and its tools (browsers, refactors, debugger). The VM is simulated and tested as a Pharo program,\n\t    once it is ready it is transpiled to C and compiled with a normal C compiler. Not all Pharo idiomatics are present in Slang, but it allows us to develop\n\t\tprograms closer to a Pharo program. However, the powerful collection API of Pharo is not available when the program is transpiled to C. \n\t\tThe goal of this topic is to generate a set of common data structures that are possible to translate to C and tested in Pharo. \n\t\tThis data structures (e.g., stack, queue, list, heap, set, dictionary) should be implemented in a way that its translation does not affect the performance of\n\t\ttheir users. Also, it includes to generate similar structures with different implementation, so the user have the option to use one or the other \n\t\t(e.g, a list based in an array and a list based in a linked-list).",
        "goal": "",
        "keywords": [
            "data structures",
            "c language",
            "transpilation"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Closing the Loop",
        "supervisors": [
            "Stephan Eggermont",
            "Christopher Fuhrman"
        ],
        "context": "Pharo wants to be able to continue to change and adapt itself to an ever changing environment. In order to do that it needs to become more modular and make currently non-essential code easy to unload and reload on demand. With the in-system tests and CI there currently is a pretty good feedback loop telling Pharo developers when they break existing in-image code.\n\nThat feedback loop is much weaker with external code. That code is often not developed in sync with the Pharo development. It is developed against a stable release or against the then current version of the development version. A lot of code is developed in student projects that don't have the continuity that Pharo itself has. Other code is developed for specific customers who are not interested in upgrading it. Even if there are sufficient tests and an automated build for that code, there often is not enough incentive and priority for it to be kept up to date.\n\nAchieving more adaptability and agility for Pharo can be found by making it easier to keep more code up to date, or by making it easier to bring removed code up to date again. This proposal is about the latter.\n\nWhen refactoring or rewriting some code, looking at the senders of a message and references to a class is one of the basic things to do to get a good understanding of how that code is actually used. Currently that only works in-image. When Pharo was a 32-bit environment that made sense, but with the current support for large images it should be possible to provide that information for all open source smalltalk code, and also to provide historic/version information for it.   \n\nSome experiments have been done already to establish the viability: code (for older Pharo versions) is available on smalltalkhub: StephanEggermont/DeprecationFinder and StephanEggermont/MonticelloProjects",
        "goal": "Analyze the source code of publicly available packages and determine which classes and methods are used and defined by them (senders/references) (see DeprecationFinder). For Monticello use the history and deduplicate source code versions to reduce the amount of data that needs to be handled (see MonticelloProjects). Apply to projects on github and older repositories like smalltalkhub.",
        "keywords": [
            "deprecations",
            "adaptability"
        ],
        "levels": [
            "Advanced"
        ]
    },
    {
        "title": "New Collections for Pharo",
        "supervisors": [
            "Juan Pablo Sandoval Alcocer",
            "Evelyn Cusi Lopez",
            "Stéphane Ducasse"
        ],
        "context": "Pharo contains a large set of collections (See http://books.pharo.org/ PharoByExample Collections chapter)\nwith around 100 classes. But new collections exist such as BTree, QuadTree, SkipList, Trie, …\n\nContainers is an existing effort to gather many of the existing collection developed individually and externally to Pharo into a single umbrella. The idea is to create a modular collection library for Pharo users. Containers’s goals is to develop new efficient, well-tested, well documented collections. \nContainers contains already Tree, Grid, SkipList, LinkedList, OrderedDictionary but there is a need to revisit them. \n\nFinally Pharo 6.0 comes with two powerful primitives: new object immutability primitives as well as ephemerons [Hayes97].\n\nWith such important primitives two tasks can be performed: \n\t- design new weak collections taking advantage of ephemerons.\n\t- revisit and design new concurrent collections taking advantage of immutability.\n\tLinks:\n- Camillo Bruni master contains a chapter on how to benchmark for collections http://scg.unibe.ch/archive/masters/Brun11a.pdf\n- http://source.lukas-renggli.ch/container started to implement some new collections for Pharo.\n- http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-851-advanced-data-structures-spring-2010/lecture-notes/",
        "goal": "Tasks:\n- The student will study current Collections of Pharo (See http://books.pharo.org/ PharoByExample Collections chapter) for an overview.\n- He will study the new collections in the project named Containers on Smalltalkhub.\n\thttp://smalltalkhub.com/#!/~StephaneDucasse/Containers\n- Migrate some existing projects to Containers (adding tests, comments).\n- Design and implement new collections such as \n\t-- BTree, QuadTrees, \n\t-- Immutable list, set, array\nResources:\n- Camillo Bruni master contains a chapter on how to benchmark for collections http://scg.unibe.ch/archive/masters/Brun11a.pdf \n- http://source.lukas-renggli.ch/container started to implement some new collections for Pharo. \n- http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-851-advanced-data-structures-spring-2010/lecture-notes/\n- Barry Hayes, Proceedings OOPSLA '97, ACM SIGPLAN Notices, Ephemerons: A new finalization mechanism, 1997",
        "keywords": [
            "collections",
            "data structures",
            "benchmarks"
        ],
        "levels": [
            "Advanced"
        ]
    },
    {
        "title": "Enhancing Pillar",
        "supervisors": [
            "Stéphane Ducasse",
            "Guillermo Polito"
        ],
        "context": "Pillar is a markup syntax that is easy to use and learn. This markup syntax generates a document tree. P\n    illar can export to HTML, LaTeX (to produce PDFs) and Markdown. Pillar has already been used in several projects \n    (http://www.smalltalkhub.com/#!/~Pier/Pillar) and most of the pharo books and mooc",
        "goal": "The goal of the project is to do help in the development of the new iteration of Pillar. Previous development effort introduced a better \n    architecture but there are still some points to improve. \n    - Documenting certain classes\n    - Improving the archetype design\n    - Separating command-line into object configurators and command-line\n    - Producing a new version of ectastic http://guillep.github.io/ecstatic/ that uses the lastest version of pillar. \n    - One subgoal of this project is to add the standard OpenDocument export format (used by LibreOffice and OpenDocument).",
        "keywords": [
            "opendocument",
            "libreoffice",
            "document"
        ],
        "levels": [
            "Beginner"
        ]
    },
    {
        "title": "Pharo Launcher command line interface",
        "supervisors": [
            "Guillermo Polito",
            "Christophe Demarey",
            "David Bajger"
        ],
        "context": "The pharo launcher is an application that allows the management of pharo images. In a \"docker style\", you can download images from templates, install them, list your installed images, and launch them. All this is done through a visual user interface in a desktop application.",
        "goal": "The goal of this project is to implement a command line interface for the Pharo launcher, to be able to manipulate it on servers as we do with docker. For example:\n       \n       $ phlauncher list\n       $ phlauncher templates\n       $ phlauncher install X\n       $ phlauncher run X",
        "keywords": [
            "image management",
            "command line interface",
            "virtualization"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Packaging the PharoLauncher using Open Build Service",
        "supervisors": [
            "Pablo Tesone",
            "Guillermo Polito"
        ],
        "context": "The Pharo Launcher is an application that is directly installed by the users. This application has developed installers for OSX and Windows, although for Linux installation packages only uses a Zip file.\n\t   Different Linux distributions have different ways of distributing applications: apt, yum, snap, rpm, etc.\n\t   Having an application packaged for each of the distributions requires developing all the processes for each of the distributions.\n\t   Open Build Services is a service provided by the comunity of openSUSE to provide a single way of packaging an application to different distributions.\n\t   The objective of this topic is to modify the build process of the Pharo Launcher and integrate it with OBS. This objective requires to modify the build process of Pharo Launcher, learn about different build systems, and to implement them in OBS.",
        "goal": "",
        "keywords": [
            "build process",
            "cmake",
            "distribution",
            "open build service"
        ],
        "levels": [
            "Advanced"
        ]
    },
    {
        "title": "Text navigation key-bindings should be aligned with the OS",
        "supervisors": [
            "Guillermo Polito",
            "Pablo Tesone"
        ],
        "context": "Pharo is a powerful IDE; it includes a powerful text editor. This editor present all the classical key navigation features (e.g., going to the beginning of the line, to the end of text, next word, etc). However the key bindings used to navigate the text are specific to Pharo (they are similar to the ones in the current OS but not the exact ones), this produce problems to the new comers and make Pharo a little odd in the look and feel of the current operating system. These set of keys are inherited from historical reasons, and some users are used to them. \n\t   The objective of this topic is to have a configurable set of key bindings for text navigation, depending on the operating system executing Pharo the key bindings will be different. Also, it is important to keep the traditional set of bindings so users can decided what to use.",
        "goal": "",
        "keywords": [
            "text editor",
            "text navigation",
            "key bindings",
            "shortcuts"
        ],
        "levels": [
            "Beginner"
        ]
    },
    {
        "title": "Better code importer",
        "supervisors": [
            "Stéphane Ducasse",
            "Aless Hosry"
        ],
        "context": "Pharo is a powerful IDE. However it needs a way to load easily code fragments writing in tonel format. \nThe idea is to be able to select, load save code and to replace the old changeset.",
        "goal": "",
        "keywords": [
            "code importer"
        ],
        "levels": [
            "Beginner"
        ]
    },
    {
        "title": "Improving ProfStef tutorial",
        "supervisors": [
            "Stéphane Ducasse",
            "Iona Thomas"
        ],
        "context": "ProfStef is an in-image tutorial that is available in a Pharo image.\nIt has all the things that are necessary for learning Pharo syntax.",
        "goal": "We want to have a more in-depth tutorial which can cover more than the basics of Pharo.\nTo have more learning resources availables inside the Pharo image.",
        "keywords": [
            "tools",
            "pharo"
        ],
        "levels": [
            "Beginner"
        ]
    },
    {
        "title": "ROS+ROS2 On Pharo",
        "supervisors": [
            "Santiago Bragagnolo"
        ],
        "context": "ROS/ROS2 is a middleware for robotics development open source. It has already more than 10 years, and is starting to seriously move to their version 2.",
        "goal": "We have already a large library on the development of ROS1 applications. In this context objective would be to develop the bindings to ROS2 and integrate it into the existing libraries.",
        "keywords": [
            "pharo",
            "robotics",
            "ros",
            "ros2"
        ],
        "levels": [
            "Intermediate",
            "Advanced"
        ]
    },
    {
        "title": "Using CFG to analyze tests",
        "supervisors": [
            "Gordana Rakic",
            "Pablo Tesone"
        ],
        "context": "The objective is to produce an initial model that represents the Control-Graph-Flow (CFG) of an Pharo application. \nFor doing so, we need to perform an static analysis on the program. The analysis of the program is done traversing Abstract Syntax Tree (AST) of the methods, and class definitions.\nPharo provides a set of existent tools to manipulate and traverse ASTs, and reflective tools to inspect programs in Pharo.\nAlso, there are implementations of required tools to be used or extended (AST interpreters, CFG extraction tools, type inferers (Phineas), etc).\nThis task can be divided in three main points: (1) developing the CFG model, (2) extract the information from the Pharo AST, (3) perform traversal and analyses over it. \nFor extracting the information in the AST and form the CGF, the student should use tools already existent in Pharo (AST interpreters / Type inferer). \nFinally, it can be possible to perform an analysis on the existing information. For example, it is possible to extract the effective classes and methods that are covered by a given test; or calculate the dependencies between classes and methods.\nThis topic provides an oportunity of working on the metalevel of programs, the student will learn how to get information from an existing program, and how to reflect about it. \nThese tools and abilities are basic when working with programming languages, refactorings, tools, etc.",
        "goal": "",
        "keywords": [
            "control flow",
            "ast",
            "tests",
            "software analysis"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "libp2p Pharo implementation",
        "supervisors": [
            "Hernán Morales"
        ],
        "context": "\" Libp2p is a modular system of protocols, specifications and libraries that enable the development of peer-to-peer network applications.\". It is the basis of the IPFS Project. This project proposes to write Pharo objects to support the libp2p networking stack. With it users will be able to establish connections between peers over the network, encrypt connections and multiplex to start a node. Also it will enable to discover peers over a public network.",
        "goal": "",
        "keywords": [
            "p2p",
            "networking",
            "ipfs"
        ],
        "levels": [
            "Intermediate"
        ]
    },
    {
        "title": "Migrating PDF-Talk to Pharo",
        "supervisors": [
            "Stephan Eggermont",
            "Sebastian Jordan"
        ],
        "context": "PDF Talk is a library for reading and writing PDF files.\nPDF files can be opened and all PDF objects are available as Smalltalk objects, which can be manipulated in any way you like. Likewise, any Smalltalk PDF object (net) can be written out as conforming PDF file.\nMore info in https://wiki.pdftalk.de/doku.php",
        "goal": "Migrate the library to Pharo and to have a first version of PDF Talk running in Pharo Smalltalk.\n ",
        "keywords": [
            "tools",
            "migration",
            "PDF"
        ],
        "levels": [
            "Intermediate"
        ]
    }
]